# Quality in agile processes #

## Process ##

The process if very important if the goal is good quality software. If the process is designed to produce software of good quality, we're more likely to end up with some.

Early delivery of a partially functioning system. This has been shown to correlate with quality

  * Subsequent releases should be frequent

Project steering cannot happen in the middle of a sprint

Stakeholders should get involved & committed.
  * The team
  * The management
  * The customer
  * The customers customer
  * etc.

The team is most important stakeholder group; without them there can be no software

Management should provide the team with the resources it needs to do it's job

Teams work best if self organized. Management happens only if it's needed. If the team has a problem with the rules the rules should change.

  * Don't let the team slip back to "doing it the old fashioned way"

The customer should be reviewing iterations and giving instant feedback. Changes should follow soon after the feedback, the team doesn't move on before this version's quality is assured.

Team works at a sustainable pace; not too fast, but not too slow either.

  * Deadlines **are** met.


Measure & review. Use functionality as the metrics; when 30% of functionality is done, we're 30% done.

## Development techniques ##

Testing isn't essential, **testing is vital**

Tend to foster communication

  * More communication `==` avoid misunderstandings among team, between team and management, between team and customer, etc.

Tend to foster reviews

  * Peer-reviews are constant and small. There is no need for heavy, all-team including review meetings (well, not maybe _always_...)

Developers learn new skills

  * Agile demands developers to leave their comfort zone and take part in all aspects of development. The more the developer works in projects, it is almost guaranteed that developers share knowledege ie. there is no _one person, one speciality_-cases .

## Development tools ##

Should make things easy to change...
  * ...which tend to enable productivity...
  * ...which, in turn, makes development faster...
  * ...which results in more ground covered...
  * ...which is why we can do more with less ie. _more quality in the same time as before_

Other tasks than actual designing and implementation are (implicitly) given the demand to be as automated as possible. This includes:
  * deployment
  * unit testing
  * integration testing
  * acceptance testing(!)
  * issue tracking
  * documentation
  * project metrics tracking

## Attitude ##

Developers attitude is expected to value the product and make it so it's what customer wants. This means instead of "doing the job" one is expected to care about the product and therefore to care about the product of being exactly what needed.