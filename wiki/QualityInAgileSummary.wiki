#summary Summary about quality in agile processes
=Quality in agile processes=

== Process ==

The process if very important if the goal is good quality software. If the process is designed to produce software of good quality, we're more likely to end up with some.

    * Early delivery of a partially functioning system correlates with quality
    * Subsequent releases should be frequent; project steering cannot happen in the middle of a sprint
    * Stakeholders should get involved & committed: the team, management and the customer
    * Management should provide the team with the resources it needs to do it's job
    * The team is most important stakeholder group; without them there can be no software
    * Teams work best if self organized; team comes first, management happens only if it's needed
    * If the team has a problem with the rules the rules should change
    * The customer should be reviewing iterations and giving instant feedback
    * Changes should follow soon after the feedback, don't move on before this version's quality is assured
    * Changing requirements are a good thing; after all, we want to make the right system
    * KISS: keep the code simple
    * Work at a sustainable pace; not too fast, but not too slow either
    * Use functionality as the metrics; when 30% of functionality is done, we're 30% done
    * Don't let the team slip back to "doing it the old fashioned way"
    * Don't let deadlines slip
    * Measure & review
    * KISS: keep the process simple, it's meant to make your life easier, not harder

==Development techniques==

Testing isn't essential, *testing is vital*

Tend to foster communication

    * More communication `==` avoid misunderstandings among team, between team and management, between team and customer, etc.

Tend to foster reviews

    * Peer-reviews are constant and small. There is no need for heavy, all-team including review meetings (well, not maybe _always_...)

Developers learn new skills

    * Agile demands developers to leave their comfort zone and take part in all aspects of development. The more the developer works in projects, it is almost guaranteed that developers share knowledege ie. there is no _one person, one speciality_-cases .

==Development tools==

Should make things easy to change... 
     * ...which tend to enable productivity...
     * ...which, in turn, makes development faster...
     * ...which results in more ground covered...
     * ...which is why we can do more with less ie. _more quality in the same time as before_

Other tasks than actual designing and implementation are (implicitly) given the demand to be as automated as possible. This includes:
    * deployment
    * unit testing 
    * integration testing
    * acceptance testing(!)
    * issue tracking
    * documentation
    * project metrics tracking

==Attitude==

Developers attitude is expected to value the product and make it so it's what customer wants. This means instead of "doing the job" one is expected to care about the product and therefore to care about the product of being exactly what needed.